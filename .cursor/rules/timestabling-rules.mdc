---
description: 
globs: 
alwaysApply: false
---
# Система автоматизации составления расписания

## Общий контекст проекта

Это система автоматизации составления расписания для учебного заведения, построенная на Django + OptaPy + PostgreSQL. Система решает задачу оптимизации с ограничениями (CSP) для составления расписания занятий.

## Архитектурные принципы

### Backend Architecture
- **Framework**: Django 4.2+ с Django REST Framework
- **Database**: PostgreSQL для основных данных, Redis для кеширования и очередей
- **Optimization Engine**: OptaPy для решения задач оптимизации
- **Task Queue**: Celery + Redis для асинхронной обработки
- **API Style**: RESTful API с четкой структурой endpoints

### Project Structure
```
schedule_automation/
├── apps/
│   ├── core/           # Базовые модели и утилиты
│   ├── academics/      # Курсы, группы, дисциплины
│   ├── faculty/        # Преподаватели и их доступность
│   ├── facilities/     # Аудитории и оборудование
│   ├── schedule/       # Расписание и оптимизация
│   ├── data_import/    # Импорт данных из Excel
│   └── notifications/  # Уведомления и статусы
├── config/             # Настройки Django
├── utils/              # Общие утилиты
└── tests/              # Тесты
```

## Бизнес-логика и ограничения

### ЖЕСТКИЕ ОГРАНИЧЕНИЯ (НЕ МОГУТ НАРУШАТЬСЯ):
1. **Конфликты преподавателей**: Один преподаватель не может вести два занятия одновременно
2. **Конфликты аудиторий**: Одна аудитория не может использоваться для двух занятий одновременно
3. **Рабочие часы**: Не более 8 часов в день у групп и преподавателей
4. **Связанные занятия**: 
   - 2 занятия одного типа ставятся подряд
   - 3 занятия: 2 подряд в один день + 1 отдельно в другой день
5. **MOOK занятия**: Онлайн занятия с отрывом на 2 часа от основных занятий
6. **Расписание по курсам**:
   - 1 курс: Первая смена, ПН-СБ, 08:00-14:00
   - 2 курс: Вторая смена, ПН-ПТ, 13:00-20:00  
   - 3 курс: Первая смена, ПН-СБ (кроме ЧТ), 08:00-14:00
7. **Военная кафедра**:
   - 2 курс: Суббота (без академических занятий)
   - 3 курс: Четверг (без академических занятий)
   - 1 курс: Нет военной кафедры
8. **Преподаватели-совместители**: Учитывать указанные ими дни и время

### МЯГКИЕ ОГРАНИЧЕНИЯ (ЖЕЛАТЕЛЬНО СОБЛЮДАТЬ):
1. Минимизировать окна у групп и преподавателей
2. Допустимое превышение вместимости аудиторий на 2-3 единицы
3. Оставлять окно до/после занятий в блоках не C1
4. Элективные потоки ставить одновременно для лекций и семинаров
5. Лекции перед семинарами (при 3 лекциях - практики между ними)
6. Занятия по одной дисциплине не должны идти два дня подряд

## Стандарты кодирования

### Django Models
```python
# Всегда используй verbose_name и help_text
class Course(models.Model):
    name = models.CharField(
        max_length=200, 
        verbose_name="Название курса",
        help_text="Полное название курса обучения"
    )
    
# Используй choices для ограниченных значений
SHIFT_CHOICES = [
    ('morning', 'Первая смена (08:00-14:00)'),
    ('evening', 'Вторая смена (13:00-20:00)'),
]

# Всегда добавляй related_name для ForeignKey
teacher = models.ForeignKey(
    Teacher, 
    on_delete=models.CASCADE,
    related_name='schedule_entries'
)
```

### API Views
```python
# Используй ViewSets для CRUD операций
class ScheduleViewSet(viewsets.ModelViewSet):
    queryset = Schedule.objects.all()
    serializer_class = ScheduleSerializer
    filterset_class = ScheduleFilter
    permission_classes = [IsAuthenticated]

# Используй APIView для кастомной логики
class OptimizeScheduleView(APIView):
    def post(self, request):
        # Валидация -> Создание задачи -> Возврат task_id
        pass
```

### OptaPy Integration
```python
# Всегда используй dataclasses для entities
@planning_entity
@dataclass
class ScheduleEntry:
    lesson: Lesson
    time_slot: TimeSlot = planning_variable(TimeSlot, ["time_slot_range"])
    room: Room = planning_variable(Room, ["room_range"])

# Constraint functions должны быть четко названы
def room_conflict(constraint_factory):
    return constraint_factory \
        .for_each_unique_pair(ScheduleEntry,
                             Joiners.equal(lambda entry: entry.time_slot),
                             Joiners.equal(lambda entry: entry.room)) \
        .penalize("Room conflict", HardSoftScore.ONE_HARD)
```

## Соглашения по именованию

### Models
- **Singular names**: `Course`, `Teacher`, `Room`
- **Descriptive names**: `ScheduleEntry`, `TeacherAvailability`
- **Related names**: `teacher.schedule_entries`, `room.bookings`

### Variables
- **snake_case**: `student_count`, `max_hours_per_day`
- **Descriptive names**: `available_time_slots`, `conflicting_entries`
- **Constants**: `MAX_DAILY_HOURS = 8`, `MORNING_SHIFT_START = '08:00'`

### Functions
- **Action-oriented**: `create_schedule()`, `validate_constraints()`
- **Boolean functions**: `is_room_available()`, `has_teacher_conflict()`

## Обработка данных

### Excel Import
```python
# Всегда валидируй входные данные
def import_teachers_from_excel(file_path):
    try:
        df = pd.read_excel(file_path)
        # Очистка данных
        df.columns = df.columns.str.strip()
        # Валидация обязательных полей
        required_fields = ['ФИО', 'Дисциплины']
        validate_required_fields(df, required_fields)
    except Exception as e:
        logger.error(f"Import error: {e}")
        raise ValidationError(f"Ошибка импорта: {e}")
```

### Database Queries
```python
# Используй select_related и prefetch_related
schedules = Schedule.objects.select_related('course') \
    .prefetch_related('entries__teacher', 'entries__room')

# Используй annotate для подсчетов
teachers_with_load = Teacher.objects.annotate(
    weekly_hours=Sum('schedule_entries__lesson_type__duration_hours')
)
```

## Тестирование

### Test Structure
```python
class TestScheduleOptimization(TestCase):
    def setUp(self):
        # Создай базовые тестовые данные
        self.course = Course.objects.create(name="Test Course")
        self.teacher = Teacher.objects.create(name="Test Teacher")
    
    def test_hard_constraint_room_conflict(self):
        # Тест жестких ограничений
        pass
    
    def test_soft_constraint_minimize_gaps(self):
        # Тест мягких ограничений
        pass
```

### Factory Pattern
```python
# Используй factory_boy для тестовых данных
class TeacherFactory(factory.django.DjangoModelFactory):
    class Meta:
        model = Teacher
    
    first_name = factory.Faker('first_name')
    last_name = factory.Faker('last_name')
    max_hours_per_day = 8
```

## Error Handling

### Custom Exceptions
```python
class ScheduleOptimizationError(Exception):
    """Базовое исключение для ошибок оптимизации"""
    pass

class HardConstraintViolationError(ScheduleOptimizationError):
    """Нарушение жесткого ограничения"""
    pass
```

### Logging
```python
import logging

logger = logging.getLogger(__name__)

def optimize_schedule(data):
    logger.info("Starting schedule optimization")
    try:
        # optimization logic
        logger.info("Optimization completed successfully")
    except Exception as e:
        logger.error(f"Optimization failed: {e}", exc_info=True)
        raise
```

## Performance Guidelines

### Database Optimization
- Используй индексы для часто запрашиваемых полей
- Избегай N+1 queries с select_related/prefetch_related
- Используй bulk_create для массовых вставок

### Caching Strategy
```python
from django.core.cache import cache

def get_available_rooms(time_slot):
    cache_key = f"available_rooms_{time_slot.id}"
    rooms = cache.get(cache_key)
    if rooms is None:
        rooms = Room.objects.filter(...)
        cache.set(cache_key, rooms, timeout=300)
    return rooms
```

## Security Considerations

### API Security
- Всегда используй authentication и permissions
- Валидируй входные данные на уровне serializer
- Логируй критические операции

### Data Validation
```python
class ScheduleEntrySerializer(serializers.ModelSerializer):
    def validate(self, data):
        # Проверка бизнес-логики
        if self.check_room_conflict(data):
            raise serializers.ValidationError("Room conflict detected")
        return data
```

## Deployment & Configuration

### Environment Variables
```python
# settings/base.py
import os
from pathlib import Path

DATABASE_URL = os.getenv('DATABASE_URL')
REDIS_URL = os.getenv('REDIS_URL', 'redis://localhost:6379/0')
OPTAPY_SOLVER_CONFIG = os.getenv('OPTAPY_SOLVER_CONFIG', 'default')
```

### Docker Configuration
- Используй multi-stage builds для production
- Настрой health checks для сервисов
- Используй docker-compose для development

## Мониторинг и отладка

### Logging Strategy
- INFO: Начало/окончание операций оптимизации
- WARNING: Мягкие ограничения не выполнены
- ERROR: Критические ошибки, нарушения жестких ограничений
- DEBUG: Детальная информация для разработки

### Metrics
- Время выполнения оптимизации
- Количество нарушенных мягких ограничений
- Использование ресурсов (CPU, память)

## Специфические требования

### MOOK Занятия
```python
def schedule_mook_lessons(schedule_entries):
    """
    MOOK занятия должны быть с отрывом на 2 часа
    от основных занятий
    """
    for entry in schedule_entries:
        if entry.lesson_type.is_mook:
            # Логика размещения с учетом отрыва
            pass
```

### Военная кафедра
```python
def block_military_department_days(course, schedule):
    """
    Блокировка дней для военной кафедры:
    - 2 курс: суббота
    - 3 курс: четверг
    """
    blocked_days = {
        2: [5],  # суббота
        3: [3],  # четверг
    }
    return blocked_days.get(course.year, [])
```

## Code Review Checklist

При создании/изменении кода проверяй:
- [ ] Соответствие naming conventions
- [ ] Покрытие тестами новой функциональности
- [ ] Валидация входных данных
- [ ] Обработка ошибок
- [ ] Документация (docstrings)
- [ ] Соответствие бизнес-требованиям
- [ ] Performance implications
- [ ] Security considerations


Эти правила должны использоваться Cursor AI для генерации качественного, согласованного кода, который соответствует архитектуре и требованиям проекта.